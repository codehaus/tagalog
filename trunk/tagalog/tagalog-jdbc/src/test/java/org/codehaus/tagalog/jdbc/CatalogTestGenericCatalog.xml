<?xml version="1.0"?>

<catalog>
  <proc name="query-no-table">
    <dialect-choice>
      <query rows="one" dialect="mysql">select 42 result</query>
      <query rows="one" dialect="oracle">select 42 result from dual</query>
    </dialect-choice>
  </proc>

  <!-- Test statements that operate on a simple (id, name) table.
       All these statements have names that begin with the string 'ttq'.
    -->

  <proc name="ttq-create-table">
    <stmt>
      create table catalog_test (
        id    integer not null primary key,
        name  char varying(20) not null
      )
    </stmt>
  </proc>

  <proc name="ttq-drop-table">
    <stmt>drop table catalog_test</stmt>
  </proc>

  <proc name="ttq-create-data">
    <stmt>insert into catalog_test values (1, 'mhw')</stmt>
    <stmt>insert into catalog_test values (2, 'fred')</stmt>
    <stmt>insert into catalog_test values (42, 'answer')</stmt>
  </proc>

  <!-- queries for zero rows -->

  <proc name="ttq-q-no-rows-get-zero">
    <query rows="zero">
      select id, name from catalog_test where id = 100
    </query>
  </proc>

  <proc name="ttq-q-no-rows-get-one">
    <query rows="zero">
      select id, name from catalog_test where id = 1
    </query>
  </proc>

  <proc name="ttq-q-no-rows-get-many">
    <query rows="zero">
      select id, name from catalog_test
    </query>
  </proc>

  <!-- queries for zero or one row -->

  <proc name="ttq-q-zero-or-one-rows-get-zero">
    <query rows="zero-or-one">
      select id, name from catalog_test where id = 100
    </query>
  </proc>

  <proc name="ttq-q-zero-or-one-rows-get-one">
    <query rows="zero-or-one">
      select id, name from catalog_test where id = 1
    </query>
  </proc>

  <proc name="ttq-q-zero-or-one-rows-get-many">
    <query rows="zero-or-one">
      select id, name from catalog_test order by id
    </query>
  </proc>

  <!-- queries for one row -->

  <proc name="ttq-q-one-row-get-zero">
    <query rows="one">
      select id, name from catalog_test where id = 100
    </query>
  </proc>

  <proc name="ttq-q-one-row-get-one">
    <query rows="one">
      select id, name from catalog_test where id = 1
    </query>
  </proc>

  <proc name="ttq-q-one-row-get-many">
    <query rows="one">
      select id, name from catalog_test order by id
    </query>
  </proc>

  <!-- queries for one or more rows -->

  <proc name="ttq-q-one-or-more-rows-get-zero">
    <query rows="one-or-more">
      select id, name from catalog_test where id = 100
    </query>
  </proc>

  <proc name="ttq-q-one-or-more-rows-get-one">
    <query rows="one-or-more">
      select id, name from catalog_test where id = 1
    </query>
  </proc>

  <proc name="ttq-q-one-or-more-rows-get-many">
    <query rows="one-or-more">
      select id, name from catalog_test order by id
    </query>
  </proc>

  <!-- queries for zero or more rows -->

  <proc name="ttq-q-zero-or-more-rows-get-zero">
    <query rows="zero-or-more">
      select id, name from catalog_test where id = 100
    </query>
  </proc>

  <proc name="ttq-q-zero-or-more-rows-get-one">
    <query rows="zero-or-more">
      select id, name from catalog_test where id = 1
    </query>
  </proc>

  <proc name="ttq-q-zero-or-more-rows-get-many">
    <query rows="zero-or-more">
      select id, name from catalog_test order by id
    </query>
  </proc>

  <!-- queries with bind variables -->

  <proc name="ttq-q-by-id">
    <query>
      select id, name from catalog_test where id = ?{id}
    </query>
  </proc>

  <proc name="ttq-q-by-name">
    <query>
      select id, name from catalog_test where name = ?{name}
    </query>
  </proc>

  <proc name="ttq-q-generic">
    <query>
      select id, name from ${table} where ${column} = ?{value}
    </query>
  </proc>

  <!-- Test statements that use bind variables, using a table with more
       columns.
    -->

  <proc name="tbind-create-table">
    <stmt>
      create table bind_test (
        id    integer not null primary key,
        a     char varying(20) not null,
        b     char varying(20) not null,
        c     char varying(20) not null,
        d     char varying(20) not null,
        e     char varying(20) not null
      )
    </stmt>
  </proc>

  <proc name="tbind-drop-table">
    <stmt>drop table bind_test</stmt>
  </proc>

  <proc name="tbind-insert">
    <stmt>
      insert into bind_test (id, a, b, c, d, e)
      values (?{id}, ?{rod}, ?{jane}, ?{freddy}, ?{zippy}, ?{bungle})
    </stmt>
  </proc>

  <proc name="tbind-query">
    <query rows="one">
      select id, a, b, c, d, e from bind_test where id = ?{id}
    </query>
  </proc>

  <!-- Test insert statements that allocate unique ids. For MySQL we use the
       JDBC 3.0 getGeneratedKeys method to return a result set containing
       the allocated key. For Oracle we perform a select after the insert to
       get the sequence value.
    -->

  <proc name="tikg-c-table">
    <dialect-choice>
      <stmt dialect="mysql">
        create table key_gen (
          id     integer not null auto_increment,
          value  varchar(40) not null,
          length integer,
          primary key(id)
        )
      </stmt>
      <sequence dialect="oracle">
        <stmt dialect="oracle">
          create table key_gen (
            id     integer not null,
            value  varchar2(40) not null,
            length integer,
            primary key(id)
          )
        </stmt>
        <stmt dialect="oracle">
          create sequence key_gen_seq
        </stmt>
      </sequence>
    </dialect-choice>
  </proc>

  <proc name="tikg-insert">
    <dialect-choice>
      <stmt dialect="mysql" generates-keys="true">
        insert into key_gen (value, length)
        values (?{value}, ?{length})
      </stmt>
      <sequence dialect="oracle">
        <stmt>
          insert into key_gen
          values (key_gen_seq.nextval, ?{value}, ?{length})
        </stmt>
        <query rows="one">
          select key_gen_seq.currval from dual
        </query>
      </sequence>
    </dialect-choice>
  </proc>

  <proc name="tikg-query">
    <query rows="one">
      select id, value, length
      from key_gen
      where id = ?{id}
    </query>
  </proc>

  <proc name="tikg-d-table">
    <stmt>drop table key_gen</stmt>
    <dialect-choice optional="true">
      <stmt dialect="oracle">drop sequence key_gen_seq</stmt>
    </dialect-choice>
  </proc>

</catalog>
